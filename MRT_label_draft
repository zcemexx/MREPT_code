%% ===================== Demo: UCL MR-EPT v2.2 + Phase-2 Label Generation =====================
% Clean demo for 3T_Brain_phantom (Integral-form Mag+Seg EPT)
%
% Assumes the following files exist under:
%   data/3T_Brain_phantom/
%       - Transceive_phase_noiseless.nii.gz
%       - Tissue_Segmentation.nii.gz
%       - T1w_noiseless.nii.gz
%       - T2w_noiseless.nii.gz (optional)
%       - Conductivity_GroundTruth.nii.gz (for evaluation & Phase 2)
%
% Author: jared
% Date:   2025/11/30

%% ===================== Dependencies and paths =====================
addpath(genpath('functions'));
addpath(genpath('toolboxes'));

%% ===================== Load data =====================
dataDir = fullfile(pwd, 'data', '3T_Brain_phantom');

% 1) Transceive phase (phi0): measured or simulated B1+ transceive phase
phi0_nii = nii_tool('load', fullfile(dataDir, 'Transceive_phase_noiseless.nii.gz'));
phi0 = phi0_nii.img;          % transceive phase ϕ0
b1pulse_phase = phi0 / 2;     % approximate transmit (B1+) phase ≈ transceive/2

% 2) Tissue segmentation & mask
seg_nii      = nii_tool('load', fullfile(dataDir, 'Tissue_Segmentation.nii.gz'));
segmentation = seg_nii.img;
mask         = segmentation > 0;   % non-zero voxels as brain mask

% 3) Magnitude image (use T1w_noiseless as default)
mag_nii   = nii_tool('load', fullfile(dataDir, 'T1w_noiseless.nii.gz'));
magnitude = mag_nii.img;

% 4) Noisemap (phantom is noiseless → not used here)
noisemap = [];  %#ok<NASGU> % placeholder for future use

%% ============ (Optional) sub-volume test for faster runtime ============
% Set doSubVolume = true if you want to run on a smaller cube (e.g. 40x40x40).
% Set doSubVolume = false to run on the full volume.

doSubVolume = true;

if doSubVolume
    sz = size(b1pulse_phase);
    cx = round(sz(1)/2);
    cy = round(sz(2)/2);
    cz = round(sz(3)/2);
    rad = 20;  % radius → 40^3 sub-volume

    xRange = (cx-rad+1):(cx+rad);
    yRange = (cy-rad+1):(cy+rad);
    zRange = (cz-rad+1):(cz+rad);

    b1pulse_phase = b1pulse_phase(xRange, yRange, zRange);
    mask          = mask(xRange, yRange, zRange);
    magnitude     = magnitude(xRange, yRange, zRange);
    segmentation  = segmentation(xRange, yRange, zRange);
end

%% ===================== Scan parameters =====================
% Basic scan / model parameters.

parameters.B0        = 3;        % [T] 3T scanner
parameters.VoxelSize = [1 1 1];  % [mm] isotropic voxels

% Differentiation / integration kernel sizes (in voxel diameter)
parameters.kDiffSize     = [3 3 3];   % baseline kernel for EPT demo
parameters.kIntegralSize = [7 7 7];

%% ===================== EPT 2.2 reconstruction (Mag+Seg, recommended) =====================
% Use B1+ phase + mask + magnitude + segmentation
% UCL MR-EPT v2.2: Integral-form Mag+Seg EPT (recommended configuration)

[conductivity, options] = conductivityMapping( ...
    b1pulse_phase, ...   % B1+ phase
    mask, ...            % brain mask
    parameters, ...      % B0, voxel size, kernel sizes
    'magnitude', magnitude, ...
    'segmentation', segmentation);

%% ===================== MR-EPT outputs (with auto versioning) =====================
% Create /results directory if needed
saveDir = fullfile(pwd, 'results');
if ~exist(saveDir, 'dir')
    mkdir(saveDir);
end

% ---- Auto versioning for output file names ----
existingFiles = dir(fullfile(saveDir, 'conductivity_ept2p2_*.nii.gz'));
if isempty(existingFiles)
    version = 1;
else
    nums = [];
    for k = 1:numel(existingFiles)
        fname = existingFiles(k).name;  % e.g. 'conductivity_ept2p2_003.nii.gz'
        numStr = regexp(fname, '(\d+)\.nii\.gz$', 'tokens');
        if ~isempty(numStr)
            nums(end+1) = str2double(numStr{1});
        end
    end
    if isempty(nums)
        version = 1;
    else
        version = max(nums) + 1;
    end
end
versionStr = sprintf('%03d', version);

% ---- Save conductivity as NIfTI (reusing phi0 header) ----
cond_nii     = phi0_nii;
cond_nii.img = conductivity;
cond_fname   = fullfile(saveDir, ['conductivity_ept2p2_' versionStr '.nii.gz']);
nii_tool('save', cond_nii, cond_fname);

% ---- Save MATLAB results (.mat) ----
mat_fname = fullfile(saveDir, ['ept_results_' versionStr '.mat']);
save(mat_fname, 'conductivity', 'options');

fprintf('\nSaved results:\n  %s\n  %s\n', cond_fname, mat_fname);

% ---- Simple quick-look: mid-slice conductivity ----
midZ = round(size(conductivity, 3)/2);
figure;
imagesc(squeeze(conductivity(:,:,midZ))'); 
axis image off; colorbar;
title(sprintf('Conductivity (mid-slice, version %s)', versionStr));
set(gca,'YDir','normal');

%% ===================== Evaluation vs Ground Truth (Research-grade) =====================
%   - Load Ground Truth conductivity
%   - Align sub-volume (if enabled)
%   - Compute global & tissue-wise MAE / RMSE
%   - Plot GT / EPT / Error
%   - Plot error histogram
%   - Save evaluation metrics

% 1) Load Ground Truth σ
gt_nii        = nii_tool('load', fullfile(dataDir, 'Conductivity_GroundTruth.nii.gz'));
sigma_gt_full = gt_nii.img;

% 2) Align GT with sub-volume (if used)
if doSubVolume && exist('xRange','var') && exist('yRange','var') && exist('zRange','var')
    sigma_gt = sigma_gt_full(xRange, yRange, zRange);
else
    sigma_gt = sigma_gt_full;
end

% 3) Basic consistency check
if ~isequal(size(sigma_gt), size(conductivity))
    warning('Size mismatch between GT and EPT conductivity. GT: [%s], EPT: [%s]', ...
        num2str(size(sigma_gt)), num2str(size(conductivity)));
end

% 4) Valid mask (brain mask & finite values)
validMask = mask & isfinite(conductivity) & isfinite(sigma_gt);

% 5) Error volumes
err_vol  = conductivity - sigma_gt;   % EPT - GT
abs_err  = abs(err_vol);

% 6) Global MAE / RMSE (within validMask)
err_vals = err_vol(validMask);
abs_vals = abs_err(validMask);

mae_global  = mean(abs_vals(:), 'omitnan');
rmse_global = sqrt(mean(err_vals(:).^2, 'omitnan'));

fprintf('\n[Global metrics within mask]\n');
fprintf('  MAE  = %.4f S/m\n', mae_global);
fprintf('  RMSE = %.4f S/m\n', rmse_global);

% 7) Tissue-wise metrics (assuming segmentation labels 1..4 etc.)

seg_in_mask = segmentation(validMask);
tissue_ids  = unique(seg_in_mask);
tissue_ids(tissue_ids == 0) = [];  % remove background

% Default dummy names; adjust according to your phantom documentation
tissueNames = containers.Map('KeyType','double','ValueType','char');
tissueNames(1) = 'Tissue1';
tissueNames(2) = 'Tissue2';
tissueNames(3) = 'Tissue3';
tissueNames(4) = 'Tissue4';

tissueMetrics = struct();

fprintf('\n[Tissue-wise metrics]\n');
for k = 1:numel(tissue_ids)
    tid   = tissue_ids(k);
    tmask = validMask & (segmentation == tid);

    if ~any(tmask(:))
        continue;
    end

    t_err  = err_vol(tmask);
    t_abs  = abs_err(tmask);

    t_mae  = mean(t_abs(:), 'omitnan');
    t_rmse = sqrt(mean(t_err(:).^2, 'omitnan'));

    if isKey(tissueNames, tid)
        tname = tissueNames(tid);
    else
        tname = sprintf('Tissue_%d', tid);
    end

    tissueMetrics(k).id    = tid;
    tissueMetrics(k).name  = tname;
    tissueMetrics(k).MAE   = t_mae;
    tissueMetrics(k).RMSE  = t_rmse;
    tissueMetrics(k).Nvox  = nnz(tmask);

    fprintf('  [%s] id=%d: MAE=%.4f, RMSE=%.4f, N=%d\n', ...
        tname, tid, t_mae, t_rmse, tissueMetrics(k).Nvox);
end

%% ===================== Evaluation figures =====================
% 8) GT / EPT / Error (mid-slice)

midZ = round(size(conductivity, 3)/2);

gt_slice   = squeeze(sigma_gt(:,:,midZ))';
ept_slice  = squeeze(conductivity(:,:,midZ))';
err_slice  = squeeze(err_vol(:,:,midZ))';

figure;
tiledlayout(1,3);

% GT
nexttile;
imagesc(gt_slice);
axis image off;
colorbar;
title('GT conductivity');
set(gca,'YDir','normal');

% EPT
nexttile;
imagesc(ept_slice);
axis image off;
colorbar;
title('EPT conductivity');
set(gca,'YDir','normal');

% Error
nexttile;
imagesc(err_slice);
axis image off;
colorbar;
title('Error (EPT - GT)');
set(gca,'YDir','normal');

evalFig_fname = fullfile(saveDir, ['ept_eval_slices_' versionStr '.png']);
saveas(gcf, evalFig_fname);

% 9) Error histogram (within mask)
figure;
histogram(err_vals, 50);
xlabel('Error (EPT - GT) [S/m]');
ylabel('Voxel count');
title(sprintf('Error histogram (version %s)', versionStr));

evalHist_fname = fullfile(saveDir, ['ept_error_hist_' versionStr '.png']);
saveas(gcf, evalHist_fname);

%% ===================== Save evaluation metrics =====================
evalMat_fname = fullfile(saveDir, ['ept_eval_' versionStr '.mat']);
evalMetrics = struct();
evalMetrics.mae_global    = mae_global;
evalMetrics.rmse_global   = rmse_global;
evalMetrics.tissueMetrics = tissueMetrics;
evalMetrics.versionStr    = versionStr;
evalMetrics.validMaskN    = nnz(validMask);

save(evalMat_fname, 'evalMetrics');

fprintf('\nSaved evaluation results:\n  %s\n  %s\n  %s\n', ...
    cond_fname, mat_fname, evalMat_fname);
fprintf('Saved figures:\n  %s\n  %s\n\n', evalFig_fname, evalHist_fname);

%% ===================== Phase 2: Patch-wise optimal radius label generation =====================
%   - Sweep multiple Laplacian kernel radii
%   - Build voxel-wise optimal radius_map (argmin MAE vs GT)
%   - Tissue-wise radius statistics + plots
%   - Build patch-level training dataset: phase_batch + radius_batch
%
%   NOTE: This is computationally heavier (nR times conductivityMapping).
%         First run with sub-volume (doSubVolume=true) to test.

doPhase2LabelGeneration = false;

if doPhase2LabelGeneration
    fprintf('\n================= Phase 2: Label generation (patch-wise optimal radius) =================\n');

    %% 1) Radius list & patch parameters
    radius_list = 1:7;        % radii to sweep
    nR          = numel(radius_list);

    patchSize   = [5 5 5];    % [Px Py Pz]
    patchStride = [2 2 2];    % stride between patch centers

    % Safety: ensure validMask exists
    if ~exist('validMask','var')
        validMask = mask & isfinite(conductivity) & isfinite(sigma_gt);
    end

    [nx, ny, nz] = size(conductivity);

    %% 2) Run conductivityMapping for each radius
    cond_multi = cell(nR,1);

    for ir = 1:nR
        r = radius_list(ir);
        kSize = 2*r + 1;   % kernel size for Laplacian

        params_r = parameters;
        params_r.kDiffSize = [kSize kSize kSize];

        % Option: make integral kernel slightly larger for stability
        params_r.kIntegralSize = max([params_r.kIntegralSize; [kSize+4 kSize+4 kSize+4]], [], 1);

        fprintf('  >> Running conductivityMapping for radius = %d (kDiffSize = [%d %d %d])...\n', ...
            r, params_r.kDiffSize(1), params_r.kDiffSize(2), params_r.kDiffSize(3));

        cond_r = conductivityMapping( ...
            b1pulse_phase, ...
            mask, ...
            params_r, ...
            'magnitude', magnitude, ...
            'segmentation', segmentation);

        cond_multi{ir} = cond_r;
    end

    %% 3) Build voxel-wise optimal radius_map via MAE vs σ_GT
    err_stack = nan(nx, ny, nz, nR, 'single');  % |σ_r - σ_GT|

    for ir = 1:nR
        c_r = cond_multi{ir};

        if ~isequal(size(c_r), size(sigma_gt))
            error('Size mismatch between cond_multi{%d} and sigma_gt.', ir);
        end

        diff_r = c_r - sigma_gt;
        diff_r(~validMask) = NaN;
        err_stack(:,:,:,ir) = abs(single(diff_r));
    end

    [~, best_idx] = min(err_stack, [], 4);  % argmin over radius dimension

    radius_map = zeros(nx, ny, nz, 'single');
    radius_map(validMask) = single(radius_list(best_idx(validMask)));

    % Save radius_map as NIfTI
    radius_nii      = phi0_nii;
    if doSubVolume && exist('xRange','var') && exist('yRange','var') && exist('zRange','var')
        % radius_map is sub-volume; header geometry未精调，这里沿用 phi0_nii
        radius_nii.img = radius_map;
    else
        radius_nii.img = radius_map;
    end
    radius_fname = fullfile(saveDir, ['radius_map_' versionStr '.nii.gz']);
    nii_tool('save', radius_nii, radius_fname);
    fprintf('Saved optimal radius map NIfTI:\n  %s\n', radius_fname);

    %% 4) Tissue-wise radius statistics
    rvals_in_mask = radius_map(validMask);
    seg_in_mask   = segmentation(validMask);

    t_ids = unique(seg_in_mask);
    t_ids(t_ids == 0) = [];

    tissueRadiusStats = struct();

    % 如果前面没定义 tissueNames，则临时定义一个
    if ~exist('tissueNames','var') || ~isa(tissueNames, 'containers.Map')
        tissueNames = containers.Map('KeyType','double','ValueType','char');
        tissueNames(1) = 'Tissue1';
        tissueNames(2) = 'Tissue2';
        tissueNames(3) = 'Tissue3';
        tissueNames(4) = 'Tissue4';
    end

    fprintf('\n[Tissue-wise optimal radius statistics]\n');
    for k = 1:numel(t_ids)
        tid   = t_ids(k);
        tmask = validMask & (segmentation == tid);

        if ~any(tmask(:))
            continue;
        end

        r_t = radius_map(tmask);

        if isKey(tissueNames, tid)
            tname = tissueNames(tid);
        else
            tname = sprintf('Tissue_%d', tid);
        end

        tissueRadiusStats(k).id    = tid;
        tissueRadiusStats(k).name  = tname;
        tissueRadiusStats(k).meanR = mean(r_t(:), 'omitnan');
        tissueRadiusStats(k).stdR  = std(r_t(:), 0, 'omitnan');
        tissueRadiusStats(k).minR  = min(r_t(:));
        tissueRadiusStats(k).maxR  = max(r_t(:));
        tissueRadiusStats(k).Nvox  = numel(r_t);

        fprintf('  [%s] id=%d: meanR = %.2f, stdR = %.2f, min=%g, max=%g, N=%d\n', ...
            tname, tid, tissueRadiusStats(k).meanR, tissueRadiusStats(k).stdR, ...
            tissueRadiusStats(k).minR, tissueRadiusStats(k).maxR, tissueRadiusStats(k).Nvox);
    end

    %% 5) Visualization: mid-slice radius map + histogram
    midZ = round(nz / 2);
    r_slice = squeeze(radius_map(:,:,midZ))';

    figure;
    imagesc(r_slice);
    axis image off;
    colorbar;
    title(sprintf('Optimal kernel radius map (mid-slice, v%s)', versionStr));
    set(gca,'YDir','normal');

    radiusSliceFig = fullfile(saveDir, ['radius_map_slice_' versionStr '.png']);
    saveas(gcf, radiusSliceFig);

    figure;
    histogram(rvals_in_mask, numel(radius_list));
    xlabel('Optimal radius');
    ylabel('Voxel count');
    title(sprintf('Histogram of optimal radius (v%s)', versionStr));

    radiusHistFig = fullfile(saveDir, ['radius_hist_' versionStr '.png']);
    saveas(gcf, radiusHistFig);

    %% 6) Build patch-level training dataset: phase_batch + radius_batch
    fprintf('\n[Phase 2] Building patch-level training dataset...\n');

    halfSize = floor(patchSize / 2); % [hx hy hz]

    xRangePatch = (1+halfSize(1)) : patchStride(1) : (nx-halfSize(1));
    yRangePatch = (1+halfSize(2)) : patchStride(2) : (ny-halfSize(2));
    zRangePatch = (1+halfSize(3)) : patchStride(3) : (nz-halfSize(3));

    centers = [];
    for ix = xRangePatch
        for iy = yRangePatch
            for iz = zRangePatch
                if ~validMask(ix,iy,iz)
                    continue;
                end
                centers(end+1,:) = [ix, iy, iz]; %#ok<AGROW>
            end
        end
    end

    Npatch = size(centers,1);
    fprintf('  Number of valid patch centers = %d\n', Npatch);

    phase_batch  = zeros(Npatch, 1, patchSize(1), patchSize(2), patchSize(3), 'single');
    radius_batch = zeros(Npatch, 1, 'int32');

    for pi = 1:Npatch
        cx = centers(pi,1);
        cy = centers(pi,2);
        cz = centers(pi,3);

        xIdx = (cx-halfSize(1)) : (cx+halfSize(1));
        yIdx = (cy-halfSize(2)) : (cy+halfSize(2));
        zIdx = (cz-halfSize(3)) : (cz+halfSize(3));

        patch_phase = b1pulse_phase(xIdx, yIdx, zIdx);

        phase_batch(pi,1,:,:,:) = single(patch_phase);
        radius_batch(pi)        = int32(radius_map(cx,cy,cz));
    end

    patchDataset_fname = fullfile(saveDir, ['phase_radius_patches_' versionStr '.mat']);
    patchMeta = struct();
    patchMeta.patchSize    = patchSize;
    patchMeta.patchStride  = patchStride;
    patchMeta.radius_list  = radius_list;
    patchMeta.centers      = centers;
    patchMeta.validMaskN   = nnz(validMask);
    patchMeta.doSubVolume  = doSubVolume;
    if doSubVolume && exist('xRange','var')
        patchMeta.xRange = xRange;
        patchMeta.yRange = yRange;
        patchMeta.zRange = zRange;
    end

    save(patchDataset_fname, ...
         'phase_batch', 'radius_batch', 'patchMeta', 'tissueRadiusStats', '-v7.3');

    fprintf('\nSaved Phase 2 patch dataset:\n  %s\n', patchDataset_fname);
    fprintf('Also saved radius map + hist figs:\n  %s\n  %s\n', radiusSliceFig, radiusHistFig);
    fprintf('\n================= Phase 2 label generation finished. =================\n\n');

end
